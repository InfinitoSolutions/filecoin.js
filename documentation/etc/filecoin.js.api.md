## API Report File for "filecoin.js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BigNumber } from 'bignumber.js';
import { EventEmitter } from 'events';
import { FilecoinSnapApi } from '@nodefactory/filsnap-types';

// Warning: (ae-forgotten-export) The symbol "Connector" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class HttpJsonRpcConnector extends EventEmitter implements Connector {
    constructor(options: string | JsonRpcConnectionOptions);
    // (undocumented)
    connect(): Promise<any>;
    // (undocumented)
    disconnect(): Promise<any>;
    // (undocumented)
    on(event: 'connected' | 'disconnected', listener: (...args: any[]) => void): this;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcConnectionOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected options: string | JsonRpcConnectionOptions;
    // (undocumented)
    protected reqId: number;
    // Warning: (ae-forgotten-export) The symbol "RequestArguments" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    request(req: RequestArguments): Promise<unknown>;
    // (undocumented)
    token?: string | undefined;
    // (undocumented)
    url: string;
}

// Warning: (ae-forgotten-export) The symbol "BaseWalletProvider" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "WalletProviderInterface" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MultisigProviderInterface" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class LightWalletProvider extends BaseWalletProvider implements WalletProviderInterface, MultisigProviderInterface {
    constructor(client: LotusClient, pwdCallback: Function, path?: string);
    // (undocumented)
    createLightWallet(password: string): Promise<string>;
    // (undocumented)
    deleteAddress(address: string): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "KeyInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    exportPrivateKey(address: string): Promise<KeyInfo>;
    // (undocumented)
    getAddresses(): Promise<string[]>;
    // (undocumented)
    getDefaultAddress(): Promise<string>;
    // (undocumented)
    getSigner(): LightWalletSigner;
    // (undocumented)
    hasAddress(address: string): Promise<boolean>;
    // Warning: (ae-forgotten-export) The symbol "Keystore" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    keystore: Keystore;
    // (undocumented)
    loadLightWallet(encryptedWallet: string): void;
    msigApproveAddSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveRemoveSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveSwapSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigApproveTransfer(address: string, proposedTransactionId: number, signerAddress: string): Promise<Cid>;
    msigApproveTransferTxHash(address: string, proposedMessageId: number, proposerAddress: string, recipientAddres: string, value: string, senderAddressOfApproveMsg: string): Promise<Cid>;
    msigCancelAddSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelRemoveSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelSwapSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigCancelTransfer(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, recipientAddres: string, value: string): Promise<Cid>;
    // Warning: (ae-forgotten-export) The symbol "ChainEpoch" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Cid" needs to be exported by the entry point index.d.ts
    msigCreate(requiredNumberOfSenders: number, approvingAddresses: string[], startEpoch: ChainEpoch, unlockDuration: ChainEpoch, initialBalance: string, senderAddressOfCreateMsg: string): Promise<Cid>;
    msigProposeAddSigner(address: string, senderAddressOfProposeMsg: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeRemoveSigner(address: string, senderAddressOfProposeMsg: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeSwapSigner(address: string, senderAddressOfProposeMsg: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigProposeTransfer(address: string, recipientAddres: string, value: string, senderAddressOfProposeMsg: string): Promise<Cid>;
    // (undocumented)
    newAddress(): Promise<string>;
    // (undocumented)
    prepareToSave(): string;
    // (undocumented)
    recoverLightWallet(mnemonic: string, password: string): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "Message" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "SignedMessage" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    sendMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    setDefaultAddress(address: string): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "Signature" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    sign(data: string | ArrayBuffer): Promise<Signature>;
    // (undocumented)
    signMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    verify(address: string, data: string | ArrayBuffer, sign: Signature): Promise<boolean>;
}

// Warning: (ae-forgotten-export) The symbol "Signer" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class LightWalletSigner implements Signer {
    constructor(keystore: Keystore);
    // (undocumented)
    sign(message: Message, password?: string): Promise<SignedMessage>;
}

// @public (undocumented)
export class LotusClient {
    constructor(connector: Connector);
    // Warning: (ae-forgotten-export) The symbol "JsonRpcAuthMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    auth: JsonRpcAuthMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcChainMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    chain: JsonRpcChainMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcClientMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    client: JsonRpcClientMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcCommonMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    common: JsonRpcCommonMethodGroup;
    // (undocumented)
    conn: Connector;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcGasMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    gasEstimate: JsonRpcGasMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcMinerMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    miner: JsonRpcMinerMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcMPoolMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mpool: JsonRpcMPoolMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcMsigMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    msig: JsonRpcMsigMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcNetMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    net: JsonRpcNetMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcPaychMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    paych: JsonRpcPaychMethodGroup;
    // (undocumented)
    release(): Promise<any>;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcStateMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    state: JsonRpcStateMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcSyncMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    sync: JsonRpcSyncMethodGroup;
    // Warning: (ae-forgotten-export) The symbol "JsonRpcWalletMethodGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    wallet: JsonRpcWalletMethodGroup;
}

// @public (undocumented)
export class LotusWalletProvider extends BaseWalletProvider implements WalletProviderInterface, MultisigProviderInterface {
    constructor(client: LotusClient);
    deleteAddress(address: string): Promise<any>;
    exportPrivateKey(address: string): Promise<KeyInfo>;
    getAddresses(): Promise<string[]>;
    getDefaultAddress(): Promise<string>;
    hasAddress(address: string): Promise<boolean>;
    msigApproveAddSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveRemoveSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveSwapSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigApproveTransfer(address: string, proposedTransactionId: number, signerAddress: string): Promise<Cid>;
    msigApproveTransferTxHash(address: string, proposedMessageId: number, proposerAddress: string, recipientAddres: string, value: string, senderAddressOfApproveMsg: string): Promise<Cid>;
    msigCancelAddSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelRemoveSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelSwapSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigCancelTransfer(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, recipientAddres: string, value: string): Promise<Cid>;
    msigCreate(requiredNumberOfSenders: number, approvingAddresses: string[], startEpoch: ChainEpoch, unlockDuration: ChainEpoch, initialBalance: string, senderAddressOfCreateMsg: string): Promise<Cid>;
    msigProposeAddSigner(address: string, senderAddressOfProposeMsg: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeRemoveSigner(address: string, senderAddressOfProposeMsg: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeSwapSigner(address: string, senderAddressOfProposeMsg: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigProposeTransfer(address: string, recipientAddres: string, value: string, senderAddressOfProposeMsg: string): Promise<Cid>;
    // Warning: (ae-forgotten-export) The symbol "NewAddressType" needs to be exported by the entry point index.d.ts
    newAddress(type?: NewAddressType): Promise<string>;
    sendMessage(msg: Message): Promise<SignedMessage>;
    setDefaultAddress(address: string): Promise<undefined>;
    sign(data: string | ArrayBuffer): Promise<Signature>;
    signMessage(msg: Message): Promise<SignedMessage>;
    verify(address: string, data: string | ArrayBuffer, sign: Signature): Promise<boolean>;
    walletImport(keyInfo: KeyInfo): Promise<string>;
}

// @public (undocumented)
export class MetamaskSigner implements Signer {
    constructor(filecoinApi: FilecoinSnapApi);
    // (undocumented)
    getDefaultAccount(): Promise<string>;
    // (undocumented)
    sign(message: Message): Promise<SignedMessage>;
}

// @public (undocumented)
export class MetamaskSnapHelper {
    constructor(connection: JsonRpcConnectionOptions);
    // (undocumented)
    error: string | undefined;
    // (undocumented)
    filecoinApi: FilecoinSnapApi | undefined;
    // (undocumented)
    installFilecoinSnap(): Promise<any>;
    }

// @public (undocumented)
export class MetamaskWalletProvider extends BaseWalletProvider implements WalletProviderInterface {
    constructor(client: LotusClient, filecoinApi: FilecoinSnapApi);
    // (undocumented)
    deleteAddress(address: string): Promise<any>;
    // (undocumented)
    exportPrivateKey(address: string): Promise<KeyInfo>;
    // (undocumented)
    getAddresses(): Promise<string[]>;
    // (undocumented)
    getDefaultAddress(): Promise<string>;
    // (undocumented)
    getSigner(): MetamaskSigner;
    // (undocumented)
    hasAddress(address: string): Promise<any>;
    // (undocumented)
    newAddress(): Promise<string>;
    // (undocumented)
    sendMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    setDefaultAddress(address: string): Promise<undefined>;
    // (undocumented)
    sign(data: string | ArrayBuffer): Promise<Signature>;
    // (undocumented)
    signMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    verify(address: string, data: string | ArrayBuffer, sign: Signature): Promise<boolean>;
}

// @public (undocumented)
export class MnemonicSigner implements Signer {
    // Warning: (ae-forgotten-export) The symbol "StringGetter" needs to be exported by the entry point index.d.ts
    constructor(mnemonic: string | StringGetter, password: string | StringGetter, path?: string);
    // (undocumented)
    addresses: string[];
    // (undocumented)
    deleteAddress(address: string): Promise<void>;
    // (undocumented)
    getAddresses(): Promise<string[]>;
    // (undocumented)
    getDefaultAddress(): Promise<string>;
    // (undocumented)
    getPrivateKey(address: string): Promise<any>;
    // (undocumented)
    hasAddress(address: string): Promise<boolean>;
    // (undocumented)
    initAddresses(): Promise<void>;
    // (undocumented)
    newAddress(n: number): Promise<void>;
    // (undocumented)
    setDefaultAddress(address: string): Promise<void>;
    // (undocumented)
    sign(message: Message): Promise<SignedMessage>;
}

// @public (undocumented)
export class MnemonicWalletProvider extends BaseWalletProvider implements WalletProviderInterface, MultisigProviderInterface {
    constructor(client: LotusClient, mnemonic: string | StringGetter, path?: string);
    // (undocumented)
    deleteAddress(address: string): Promise<any>;
    // (undocumented)
    exportPrivateKey(address: string): Promise<KeyInfo>;
    // (undocumented)
    getAddresses(): Promise<string[]>;
    // (undocumented)
    getDefaultAddress(): Promise<string>;
    // (undocumented)
    getSigner(): MnemonicSigner;
    // (undocumented)
    hasAddress(address: string): Promise<boolean>;
    msigApproveAddSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveRemoveSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigApproveSwapSigner(address: string, senderAddressOfApproveMsg: string, proposedMessageId: number, proposerAddress: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigApproveTransfer(address: string, proposedTransactionId: number, signerAddress: string): Promise<Cid>;
    msigApproveTransferTxHash(address: string, proposedMessageId: number, proposerAddress: string, recipientAddres: string, value: string, senderAddressOfApproveMsg: string): Promise<Cid>;
    msigCancelAddSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelRemoveSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigCancelSwapSigner(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigCancelTransfer(address: string, senderAddressOfCancelMsg: string, proposedMessageId: number, recipientAddres: string, value: string): Promise<Cid>;
    msigCreate(requiredNumberOfSenders: number, approvingAddresses: string[], startEpoch: ChainEpoch, unlockDuration: ChainEpoch, initialBalance: string, senderAddressOfCreateMsg: string): Promise<Cid>;
    msigProposeAddSigner(address: string, senderAddressOfProposeMsg: string, newSignerAddress: string, increaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeRemoveSigner(address: string, senderAddressOfProposeMsg: string, addressToRemove: string, decreaseNumberOfRequiredSigners: boolean): Promise<Cid>;
    msigProposeSwapSigner(address: string, senderAddressOfProposeMsg: string, oldSignerAddress: string, newSignerAddress: string): Promise<Cid>;
    msigProposeTransfer(address: string, recipientAddres: string, value: string, senderAddressOfProposeMsg: string): Promise<Cid>;
    // (undocumented)
    newAddress(): Promise<string>;
    // (undocumented)
    sendMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    setDefaultAddress(address: string): Promise<void>;
    // (undocumented)
    sign(data: string | ArrayBuffer): Promise<Signature>;
    // (undocumented)
    signMessage(msg: Message): Promise<SignedMessage>;
    // (undocumented)
    verify(address: string, data: string | ArrayBuffer, sign: Signature): Promise<boolean>;
}

// @public (undocumented)
export class WsJsonRpcConnector extends EventEmitter implements Connector {
    // Warning: (ae-forgotten-export) The symbol "WebSocketConnectionOptions" needs to be exported by the entry point index.d.ts
    constructor(options: WebSocketConnectionOptions);
    // (undocumented)
    closeSubscription(subscriptionId: string): Promise<void>;
    // (undocumented)
    connect(): Promise<any>;
    // (undocumented)
    disconnect(): Promise<any>;
    // Warning: (ae-forgotten-export) The symbol "SubscriptionId" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    on(event: 'connected' | 'disconnected' | 'error' | SubscriptionId, listener: (...args: any[]) => void): this;
    // (undocumented)
    request(args: RequestArguments): Promise<any>;
    // (undocumented)
    token?: string;
    // (undocumented)
    url: string;
    }


// (No @packageDocumentation comment for this package)

```
